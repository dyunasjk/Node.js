2. 알아두어야할 자바스크립트: ES2015+ 문법

    ES-ECMAScript
    ES2015 --- ES6

2.1 ES2015+
    2015년 발표 자바스크립트 표준 문법안: 상당한 변화
    2016년 승인 후 ES6

    호이스팅: 함수안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것
            함수 내에서 아래쪽에 존재하는 내용 중 필요한 값을을 끌어올리는 것.
    호이스팅 대상: var변수 선언, 함수선언문에서만 발생
                  선언만 위로 끌어 올려지며, 할당은 해당 X

    바벨: 구형 브라우저에서 ES6 돌아가게 해주는 도구

2.1.1 const, let

    기존 변수 선언: var(이전버전)
    하지만 문제점 다수 ---> const, let으로 대체
    어떤 문제점?
    1. 호이스팅이라 하는 문제 =>가독성이 떨어진다
    (변수의 선언이 아무곳에서 이뤄져서 소스코드 이해도가 떨어진다.)
    함수 스코프라는 개념과도 연계
    var는 아무곳에서 선언가능 => 어나니머스 콜스택에도 포함된다.
    함수 스코프: 함수 내에서의 영역
    2. const, let : 블록 스코프
    ??(물음표 따라 블록의 종류가 달라진다.) { 
        // block
    }
    if(true) {
    var x = 3; // 전역 스코프 또는 함수 스코프 만약 코드가 정말 길어진다면, 해당 변수를 찾기가 정말 어려워진다.
    } console.log(x);
    if (true) {
    const y =3;
    } console.log(y);

    * const, let의 차이
    const a = 0;
    a = 1; Uncaught TypeError: Assignment to constant variable. at <anonymous>:2:7
    => 상수 선언, 초기화 1회만 가능, 값수정 불가
       반드시 초기화 1회 해야환다.
    let b = 0;
    b =1; // 변수 선언, 초기화및 값수정이 자유로움

    const getA = function(a) {}; 과 같은 구문을 자주 사용하게 될 것
    자바 스크립트의 특징 : 함수형 프로그래밍이 가능해지게끔 한다.

2.1.2 템플릿 문자열
    * 문자열 표현
    - ''
    - " "
    - 백틱, `` esc키 밑에 있는 ~~키 (쉬프트 x)
      템플릿 문자열로 문자열 내부에 변수 사용 가능

      var n1=1;
      var n2=2;
      var res=3;
      var string1 = n1+'add'+n2+'is \''+res + '\'';
      console.log(string1);

      var string2 = `${n1} 더하기 ${n2} 는 '${res}'`;
      console.log(string2);

2.1.3 객체 리터럴
    * literal 이란? : 구체적인 값
        1, 123, "정건희" 등등 모두 리터럴 이라 함

    * object literal : 생성된 객체, 실행된 도중에 객체의 속성, 메소드를 동적으로
                       추가 가능하다.
    - 이전버전 : 교과서 69페이지 참조, 지금도 사용 가능
    var sayNode = function() {
        console.log('node');
    }; 
    var es = 'ES';
    var oldObject = { // 이전 버전 객체 리터럴 사용 초기화
        sayJS: function() {
            console.log('JS');
        }, sayNode: sayNode,
    };
    oldObject[es + 6] = 'fantastic';
    oldObject.sayNode();
    oldObject.sayJS();
    console.log(oldObject.ES6);
    oldObject.ES6 = 'test';
    console.log(oldObject.ES6);

    - 최신버전 : 속성 명에 변수 사용 가능

    const newObject = { 
        sayJS() {
            console.log('JS');
        }, sayNode, [es+6]: 'fantastic', // sayNode:sayNode - key : value
                                         //=> 속성명과 변수명이 동일한 경우에는 한번만 써도 된다
    };
    newObject.sayNode();
    newObject.sayJS();
    console.log(newObject.ES6);

    - 객체의 표현은 {}로 표현
    - {name: name,age:age} 를 {name,age}로 줄일 수 있다.

2.1.4 화살표 함수 arrow function
    - 기존 : function을 이용하여 함수를 정의(선언)
    - 신규 : '=>' 기호를 사용 : 화살표 함수
    function add1 (x, y) {
    return x + y;
    const add2 = (x, y) => {
    return x + y;
    } ;
    const add3 = (x, y) => x + y;
    const add4 = (x, y) => (x + y); // 함수내의 명령이 한개이고, 리턴문
    function not1(x) {
    return !x; }
    const not2 = x => !x;

    * old 와 new의 차이점: this의 바인드 방식 차이 (bind)
    this = 현재의 객체
    - old의 객체 내부의 함수에서 this를 바로 접근 못함
    that 처럼 다른 변수로 할당받아서 사용
    const let은 사용 가능한가?
    var - 함수 스코프, const let - 블록 스코프라는 차이점을 주의
    - new에서의 this는 자신의 객체를 의미
        forEach문은 내부에 콜백함수를 활용하여 실행
        forEach문: 나열 가능한 객체(iterable)에 들어있는 원소 각각에 대해
                   매개 변수인 콜백함수를 호출함
    71페이지 아래쪽 예제
    아래쪽 forEach문에서 상위스코프의 this를 그대로 물려받는 것이 가능

2.1.5 구조분해 할당
    - old
    객체와 배열로부터 속성 또는 요소 접근을 하려면
    객체명.속성명 or 객체명[속성명]
    배열명.[인덱스] 와 같은 식으로 운용
    처리해야하는 한두개 때문에 객체로 연산하는 것은 불합리하다!

    const a = oldObject;
    = = (대입 또는 할당 연산자)의 왼쪽에는 리터럴, 수식 사용 불가

    * 객체의 속성명(키-콜론 왼쪽)과 할당 받을 변수를 같게 해야한다.

    const {getCandy, status:{count}} = candyMachine; 이게 가능해짐 

    - new 

2.1.6 Class: 클래스 문법은 ES6에서 새로 도입
    - 자바스크립트를 학술적으로는 객체지향 언어라 하지 않음
    - 객체중심언어, 프로토타입 기반 언어 (Prototype based Language)
      Classless Language, Instance based Language
    - 프로토타입: 원형 - 객체를 사용하는데, 객체의 원형만 가지고 있고
      실행 도중에 속성, 메소드를 추가 또는 삭제가 가능
    - 상속, 다형성 구현이 가능하나 매우 어려움

    * 프로토타입 상속 예제 코드
    var Human = function(type) {
        this.type = type || 'human';
    }; // this를 사용함으로 Human을 클래스 명이자 생성자 역할을 하게 함
    Human.isHuman = function(human) {
        return human instanceof Human; // instanceof 연산자
    } //h.isHuman(man); //클래스 메소드 구현

    Human.prototype.breathe = function() {
        alert('h-a-a-a-m'); // 일반 메소드
    }; // 상기까지 Human 객체 정의

    var Zero = function(type, firstName, lastName) {
        Human.apply(this, arguments);
        this.firstName = firstName;
        this.lastName = lastName;
    }; // Zero 객체가 Human 객체를 상속한 것으로 연결

    Zero.prototype = Object.create(Human.prototype);
    // object내부 create메소드를 이용해 Human객체의 원형을 복사하여 Zero에 붙여 넣는다
    Zero.prototype.constructor = Zero; // 비로소 상속 완성

    Zero.prototype.sayName= function() {
        alert(`${this.firstName} : ${this.lastName}`);
    }; // 자식객체의 메소드 구현

    var oldZero = new Zero('human', 'Yeongjin', 'kim');
    Human.isHuman(oldHuman);

    * Class 문법 도입 : 새로운 코드
    class Human {
        constructor(type = 'human') {
        // 생성자, 매개변수 1개, human - default값 설정
        // let hu = new Human();, let hu2 = new Human('woman');
            this.type = type; // 속성을 정의 this를 이용
        }
        static isHuman(human) { //클래스 메소드 정의
            return human instanceof Human;
        }
        breathe() { // 일반 메소드 정의
            alert('h-a-a-a-m');
        }
    }

    class Zero extends Human { // 상속관계 정의
        constructor(type, firstName, lastName) {
            super(type);
            this.firstName = firstName;
            this.lastName = lastName;
        }
        sayName() {
            super.breathe();
            alert(`${this.firstName} : ${this.lastName}`);
        }
    }
    const newZero = new Zero('human', 'Zero', 'Cho');
    Human.isHuman(newZero);

    //프로토타입 체인이라는 개념 찾아보기

2.1.7 프로미스: promise
    - 프로미스 이전의 비동기 : 콜백 처리
    ES6부터는 프로미스 사용 권장
    - 반드시 알아가야할 객체
    - 비동기 처리에서 성공, 실패의 경우를 나눠서 구현
    - 프로미스 사용 이유 또는 문법 개발 배경
      콜백 지옥현상 극복을 위해

    - 프로미스 사용 규칙
    1) 프로미스 객체 생성 : resolve();, reject()를 매개변수로 가진 콜백함수(화살표 함수)
    2) 생성된 객체에 then(), catch(), fianlly 메소드를 호출
       세개의 메소드의 매개변수: 콜백함수로 구현
        resolve() 호출 --> then()실행
        reject() --> catch() 실행
        호출하건 안하건 --> finally() 실행

    const condition = true;
    const promise = new Promise((resolve, reject) => {
        if (condition) {
            resolve('success');
        } else {
            reject('fail');
        }
    });

    promise
    .then((message) => {
        console.log(message); // 성
    }) .catch ((error) => {
        console.error(error);
    }) .fianlly(() => {
        console.log('무조건');
    })