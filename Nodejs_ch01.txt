1. 노드 시작하기

자바스크립트 이해: https://ko.javascript.info/

기술면접에서는 주로 1장의 기본적인 내용을 물어보므로 주의

1.1 핵심 개념 이해하기
*Node.js의 정의:
    크롬 v8 자바스크릡트 엔진으로 빌드된 자바스크립트 런타임
    Runtime - 실행 시간
    => Node.js 란 자바스크립트를 실행시키는 실행환경
    자바로 비유하자면 JVM, 윈도우로 치면 .Net Framework

1.1.1 서버
    서버: 네트워크를 통해서 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램
    클라이언트: 사용자PC, 모바일기기, IoT장비 등등 서버에 서비스를 요청하는 컴퓨터 또는 프로그램 (예: 웹 브라우저)

    Front-end                                       Back-end
    |클라이언트(client|---------> 요청(Request, Req) |server| ======= |DB|
    React(공부해야함)  <--------- 응답(Response, Res) JSP, PHP
    Vue(공부해야함)
    앙골라

    Node.js는 서버를 개발하는 언어
    요청에 대한 최종적인 출력은 html(+css, javascript)
    자바스크립트는 클라이언트에서 돌아간다. 
    Node.js와 자바스크립트는 많이 비슷하지만 서로 다른점이 있으니 주의.
    자바스크립트를 선행해서 공부하자.

        Server
        Client
        Request
        Response

1.1.2. 자바스크립트 런타임: 자바스크립트 실행환경, 실행기 등등의 의미를 가지고 있다. 
        (Node.js 개발자 이름: 라이언 달)
    이거 존나 중요함 암튼 중요함!!
    * Node.js의 특징: 세가지 논블로킹 I/O, 이벤트 기반 처리, 싱글 스레드
    libuv: 논 블로킹 I/O, 이벤트 기반 처리를 담당
    v8: 자바스크립트 엔진(해석기) : 아래 두개를 포함
    => 메모리 힙(Memory Heap): 메모리 할당이 일어나는 곳
       콜스택(Call Stack) : 코드가 실행될 때 쌓이는 곳.

1.1.3. 이벤트 기반(Event-driven)

    1) Event: 클릭, 키보드 입력, 화면 변화, 등등 컴퓨터에서 발생되는 시스템의 변화
        특정 이벤트가 발생할 때 무엇을 할지 미리 등록이 필요=> 이벤트 리스너에 콜백 함수를 등록한다고 표현        

       Event - Event Listener
               CallBack Function --> 함수로 구현, 콜백함수
    * Event Loop (이벤트 루프)

    - 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 판단
    - 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당. 노드가 종료될 때까지 이벤트 처리를 위한 작업 반복 => 루프라고 부르는 이유
    - CallStack 및 CallBackQueue의 상태를 체크하여 콜스택이 빈상태가 되면 콜백 큐의 첫번째 콜백을 콜스택으로 밀어넣는다.
      이러한 반복적인 행동을 틱이라 한다.

    * 행동 정리
    1) 자바스크립트 엔진에서 코드가 실행되면 콜스택에 적중
    2) 스택의 선입후출의 룰이 따라 제일 마지막에 들어온 함수가 먼저 실행, 스택에 쌓인 함수가 모두 실행
    3-1) 비동기 함수가 실행된다면, Web API가 호출
    3-2) Web API가 비동기 함수의 콜백함수를 콜백큐에 밀어넣는다.
    3-3) 이벤트 루프는 콜스택이 빈상태가 되면 콜백 큐에 있는 첫번째 콜백을 콜 스택으로 이동
    4) 이걸 반복하며 이러한 과정을 틱(Tick)이라 그런다.
    => Web API, CallBackQueue, EventLoop덕분에 멀티스레드 처럼 보여진다.

    * Call Stack (호출 스택) : LIFO(Last In First Out)
      Call Back queue (콜백 큐) : FIFO(First In First Out)의 자료 구조
                                     비동기적으로 실행된 콜백함수가 보관되는 영역.


    * Global Context(자바에서 전역변수) : 
    <-> Local Context(자바에서 지역변수) : 다른 곳에서 사용 불가(메모리가 날아감)
    Context: 함수 실행 시 사용가능한 환경 (메모리 정보, 변수)
    anonymous 함수(main()): 처음 실행 시의 Global Context()

    *-* 중요 필요 개념*-*
    -1. 태스크 큐(task queue) : 이벤트 발생 후 백그라운드에서는 태스크큐로 이벤트 리스너의 콜백함수를 보낸다.
                                정해진 순서대로 콜백들이 줄 서 있으므로 콜백 큐라고도 함.
                                콜백들은 보통 완료된 순서대로 줄을 서있지만 특정 경우 순서 변경되기도 함.
    -2. 이벤트 루프(event loop) : 위 정리 참조
    -3. 백그라운드 (background): 이벤트 리스너들이 대기하는 곳.
                                자바스크립트가 아닌 다른언어로 작성된 프로그램이라 생각.
                                여러 작업이 동시에 실행 가능

    * SetTimeout -> 콜백 이해
    ms 이후에 등록한 홤수(콜백 함수)를 실행시킨다.

    - 이벤트 루프 : 이벤트 발생 시 호출할 콜백함수들을 관리
                    콜백 함수의 실행 순서를 결정
    - 백그라운드 : 타이머, 이벤트 리스너가 대기
                  여러 작업이 동시에 시행될 수 있다.
    - 태스크 큐 : 이벤트 발생 후 백그라운드에서 태스크 큐로 타이머나 이벤트 리스너를 전송, 큐의 순서대로 실행된다.


    2) ex) 책 내용 참조
    function first() {
    second();
    console.log("첫 번째");
    }
    function second() {
        third();
        console.log("두번째");
    }
    function third() {
        console.log("세번째");

    }
    first(); 실행결과는 스택에 따른 제일 마지막에 호출된 세번째 부터 시행

    - 예제 기준 설명
    1) 전역 컨텍스트인 어나니머스가 호출스택에 들어갑니다.
    2) 그 뒤 setTimeout이 호출 스택에 들어갑니다.
    3) 호출 스택에 들어간 순서와 반대로 실행되므로, setTimeout이 먼저 실행됩니다.
    4) setTimeout이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고, setTimeout은 호출스택에서 빠집니다.
    5) 그다음으로 anonymous가 호출 스택에서 빠진다
    6) 런 함수를 태스크 큐로 전송 => 3초 후 빠진다는 것은 백그라운드에 맡겨진 작업 완료된 것
    
    부가 설명   
    1) 이벤트 루프가 run 콜백을 콜백 큐에서 꺼내 호출 스택을 올린ㄷ.
    2) 호출 스택으로 올려진 런은 실행되고, 실행 완료 후 호출 스택에서 비워진다.
    3) 이벤트 루프는 콜백 큐에 콜백 함수가 들어올 때까지 계속 대기
    4) 만약 호출 스택에 함수들이 너무 많이 들어있으면 run 함수가 실행되지 않을 수도 있다.
    5) 이벤트 루프는 호출 스택이 비어 있을 때만 콜백 큐에 있는 run함수를 호출 스택으로 가져옴
    6) 이것이 setTimeout의 시간이 정확하지 않을 수도 있는 이유

1.1.4. 논블로킹I/O

    1) 논블로킹(절대 동시랑 같은 의미가 아님) : 비동기 / 호출되는 함수가 바로 리턴여부 (이전 작업이 완료될 때까지 대기하지 않고 다음 작업 수행)
    * 주의1: 논블로킹 방식을 코드를 작성하더라도 전부 본인 작성 코드 시 실행 순서만 바뀔뿐, 시간은 감소하지 않는다.
    => 본인 작성 코드는 서로 동시에 실행되지 않기 때문
    * 주의2: I/O 작업이 없다해서 논블로킹이 의미없는건 아님. 오래 걸리는 작업을 처리 시, 논 블로킹 방식으로 순서를 바꿔
             간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있다.

    2) 블로킹 : 동기 / 이전 작업이 끝나야만 다음 작업을 수행
    3) 비동기 : ASync / 호출되는 함수의 작업완료 여부를 누가 신경쓰냐, 호출되는 함수가 호출한 함수를 신경씀
    4) 동기 : Sync / 함수가 신경씀

    ex)
    function longRunningTask () {
    console .log ("finish work"); } 
    console .log ('start work'); 
    setTimeout(longRunningTask, 5000); // setTimeout(callback, 0) 논블로킹으로 만들기 위해 사용하는 기법중 하나
    console . log ('next work') ;  //작업끝 출력되기 전까지는 오랜기간 실행 안됨
    
1.1.5. 싱글 스레드

    * process vs. thread
    1) process: 운영체제에서 할당하는 작업의 단위. 노드나 웹브라우저 같은 프로그램은 개별적인 프로세스.
                프로세스 간에는 메모리 등의 자원을 공유하지 않음.

    2) thread: 프로세스 내에서 실행되는 흐름의 단위. 프로세스는 스레드를 여러개 생성해 여러 작업을 동시에 처리 가능
               스레드들은 부모 프로세스의 자원을 공유.
               같은 주소의 메모리에 접근 가능하므로 데이터 공유 가능

    * 주의1: 노드는 싱글 스레드로 동작하지 않는다.
    - 노드 실행 시 프로세스 하나 생성
    - 프로세스가 스레드 생성
    - 이 때 내부적으로 스레드를 여러 개 생성하지만, 제어가능한 스레드는 한개 뿐
    => call Stack은 한개라는 의미
    - 노드가 싱글 스레드로 동작하지 않는 경우
        1. 스레드풀: 노드가 특정 동작을 수행할 때 스스로 멀티스레드 사용.
                    ex) 암호화, 파일 입출력, 압축 등등
        2. 워커 스레드: 노드 12버전에서 안정화 된 기능. 노드 12버전 이후부터 멀티스레드 가능.
                        프로그래머가 직접 멀티 스레드 운용 가능
                        CPU작업이 많을 경우 워커스레드 사용
        워커스레드는 일반적으로 권하지 않음


    * node의 실행 파일 : node.exe
    node에서 사용자(프로그래머)가 사용할 수 있는 스레드는 하나

    * 멀티 스레드 방식으로 프로그래밍하는 것은 어려우므로 멀티 프로세싱 방식을 사용
    * 멀티스레드 vs 멀티 프로세싱
    1) 멀티 스레드 특징
    - 하나의 프로세스 안에서 여러개의 스레드 사용
    - CPU 작업이 많을 때 사용
    - 프로그래밍이 어려움
    
    2) 멀티 프로세싱 특징
    - 여러개의 프로세스 사용
    - I/O 요청이 많을 때 사용
    - 프로그래밍이 비교적 쉬움

1.2 서버로서의 노드

    서버: I/O 많이 일어남, 효율적 방법 모색 필요
    서버로서의 노드 : 싱글 스레드, 논블로킹
    => 노드 서버의 장단점은 싱글 스레드, 논블로킹 모델의 장단점과 크게 다르지 않다.
    논블로킹 방식으로 코드 처리시 libuv 라이브러리를 사용하여 I/O 작업을 논 블로킹 방식으로 처리
    => 위와 같은 특성 덕분에 스레드 하나가 많은 수의 I/O 처리가 가능
    
    장점: 하나의 스레드 많은 I/O 대응(I/O 횟수는 많고 데이터 량이 적음)
    1) 멀티 스레드 방식에 비해 적은 컴퓨터 자원 사용
    2) I/O 처리 작업을 libuv 라이브러리에서 논블로킹 방식으로 처리하기 때문에
       I/O작업이 많은 서버로 적합
    3) 멀티 스레드 방식보다 쉬움
    4) 웹 서버가 내장되어있음
    5) 자바스크립트를 사용함
    6) JSON 형식과 쉽게 호환됨
    사용 예시: 실기간 채팅, 주식사이트, JSON 데이터 제공 API서버(API)

    단점: 
    1) 기본적으로 싱글 스레드라서 CPU코어를 하나만 사용
    2) CPU 작업이 많은 서버로는 부적합 (게임서버 등)
    3) 하나뿐인 스레드가 멈추지 않도록 관리가 필요함
    4) 서버 규모가 커졌을 때 서버를 관리하기 어려움
    5) 어중간한 성능

    특징:
    - 개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는데 적합
      ex) 네트워크, 데이터베이스, 디스크 작업 등등
    - CPU 작업을 위해 AWS나 Google Clouds Functions같은 서비스를 CPU를 많이 사용하는 작업 처리에 사용 고려
    - 싱글 스레드 방식으로 서버를 운영할 경우 하나뿐인 스레드가 에러로 인해 멈추지 않도록 관리 필요
    - 웹서버 내장(별도의 서버 설치 필요 X). 단, 서버 규모 커질경우 별도의 웹서버 연결 필요
    - 자바스크립트를 사용해 하나의 언어로 웹사이트 및 서버까지 개발 가능
    - 안정성 및 보안성 측면의 문제도 검증 완료
    - 나사, 에어비앤비, 월마트, 이베이, 네이버, 카카오톡, 위메프, 야놀자, 페이팔, 넷플릭스, 나사, 월마트, 링크드인, 우버 등에서 메인 또는 서브 서버로 사용

1.3 서버 외의 노드 : 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용 중

    - 웹 프레임워크: 앵귤러(구글 진영 프론트엔드 앱), 리액트(페이스북), 뷰 등
    - 모바일: 리액트 네이티브(페이스북, 인스타그램, 핀터레스트, 월마트, 테슬라)
    - 데스크톱 개발도구: 일렉트론(아톰, 슬랙, 디스코드, 비주얼 스튜디오 코드 등)

    